{
  "version": 3,
  "sources": ["../../../../../node_modules/rxfire/storage/index.esm.js", "../../../../../node_modules/@angular/fire/fesm2022/angular-fire-storage.mjs"],
  "sourcesContent": ["import { getDownloadURL as getDownloadURL$1, getMetadata as getMetadata$1, uploadBytesResumable as uploadBytesResumable$1, uploadString as uploadString$1 } from 'firebase/storage';\nimport { Observable, from } from 'rxjs';\nimport { shareReplay, map } from 'rxjs/operators';\n\nfunction fromTask(task) {\n    return new Observable(function (subscriber) {\n        var lastSnapshot = null;\n        var complete = false;\n        var hasError = false;\n        var error = null;\n        var emit = function (snapshot) {\n            lastSnapshot = snapshot;\n            schedule();\n        };\n        var id = null;\n        /**\n         * Schedules an async event to check and emit\n         * the most recent snapshot, and complete or error\n         * if necessary.\n         */\n        var schedule = function () {\n            if (!id) {\n                id = setTimeout(function () {\n                    id = null;\n                    if (lastSnapshot)\n                        subscriber.next(lastSnapshot);\n                    if (complete)\n                        subscriber.complete();\n                    if (hasError)\n                        subscriber.error(error);\n                });\n            }\n        };\n        subscriber.add(function () {\n            // If we have any emissions checks scheduled, cancel them.\n            if (id)\n                clearTimeout(id);\n        });\n        // Emit the initial snapshot\n        emit(task.snapshot);\n        // Take each update and schedule them to be emitted (see `emit`)\n        subscriber.add(task.on('state_changed', emit));\n        // task is a promise, so we can convert that to an observable,\n        // this is done for the ergonomics around making sure we don't\n        // try to push errors or completions through closed subscribers\n        subscriber.add(from(task).subscribe({\n            next: emit,\n            error: function (err) {\n                hasError = true;\n                error = err;\n                schedule();\n            },\n            complete: function () {\n                complete = true;\n                schedule();\n            },\n        }));\n    });\n}\nfunction getDownloadURL(ref) {\n    return from(getDownloadURL$1(ref));\n}\n// TODO: fix storage typing in firebase, then apply the same fix here\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getMetadata(ref) {\n    return from(getMetadata$1(ref));\n}\n// MARK: Breaking change (renaming put to uploadBytesResumable)\nfunction uploadBytesResumable(ref, data, metadata) {\n    return new Observable(function (subscriber) {\n        var task = uploadBytesResumable$1(ref, data, metadata);\n        var subscription = fromTask(task).subscribe(subscriber);\n        return function unsubscribe() {\n            subscription.unsubscribe();\n            task.cancel();\n        };\n    }).pipe(shareReplay({ bufferSize: 1, refCount: true }));\n}\n// MARK: Breaking change (renaming put to uploadString)\nfunction uploadString(ref, data, format, metadata) {\n    return from(uploadString$1(ref, data, format, metadata));\n}\nfunction percentage(task) {\n    return fromTask(task).pipe(map(function (snapshot) { return ({\n        progress: (snapshot.bytesTransferred / snapshot.totalBytes) * 100,\n        snapshot: snapshot,\n    }); }));\n}\n\nexport { fromTask, getDownloadURL, getMetadata, percentage, uploadBytesResumable, uploadString };\n\n", "import { ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, VERSION, ɵAngularFireSchedulers, ɵAppCheckInstances, ɵzoneWrap } from '@angular/fire';\nimport { from, timer } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Optional, NgModule, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { AuthInstances } from '@angular/fire/auth';\nimport { registerVersion } from 'firebase/app';\nimport { fromTask as fromTask$1, percentage as percentage$1 } from 'rxfire/storage';\nimport { connectStorageEmulator as connectStorageEmulator$1, deleteObject as deleteObject$1, getBlob as getBlob$1, getBytes as getBytes$1, getDownloadURL as getDownloadURL$1, getMetadata as getMetadata$1, getStorage as getStorage$1, getStream as getStream$1, list as list$1, listAll as listAll$1, ref as ref$1, updateMetadata as updateMetadata$1, uploadBytes as uploadBytes$1, uploadBytesResumable as uploadBytesResumable$1, uploadString as uploadString$1 } from 'firebase/storage';\nexport * from 'firebase/storage';\nclass Storage {\n  constructor(auth) {\n    return auth;\n  }\n}\nconst STORAGE_PROVIDER_NAME = 'storage';\nclass StorageInstances {\n  constructor() {\n    return ɵgetAllInstancesOf(STORAGE_PROVIDER_NAME);\n  }\n}\nconst storageInstance$ = timer(0, 300).pipe(concatMap(() => from(ɵgetAllInstancesOf(STORAGE_PROVIDER_NAME))), distinct());\nconst PROVIDED_STORAGE_INSTANCES = new InjectionToken('angularfire2.storage-instances');\nfunction defaultStorageInstanceFactory(provided, defaultApp) {\n  const defaultStorage = ɵgetDefaultInstanceOf(STORAGE_PROVIDER_NAME, provided, defaultApp);\n  return defaultStorage && new Storage(defaultStorage);\n}\nfunction storageInstanceFactory(fn) {\n  return (zone, injector) => {\n    const storage = zone.runOutsideAngular(() => fn(injector));\n    return new Storage(storage);\n  };\n}\nconst STORAGE_INSTANCES_PROVIDER = {\n  provide: StorageInstances,\n  deps: [[new Optional(), PROVIDED_STORAGE_INSTANCES]]\n};\nconst DEFAULT_STORAGE_INSTANCE_PROVIDER = {\n  provide: Storage,\n  useFactory: defaultStorageInstanceFactory,\n  deps: [[new Optional(), PROVIDED_STORAGE_INSTANCES], FirebaseApp]\n};\nclass StorageModule {\n  constructor() {\n    registerVersion('angularfire', VERSION.full, 'gcs');\n  }\n  static ɵfac = function StorageModule_Factory(t) {\n    return new (t || StorageModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StorageModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_STORAGE_INSTANCE_PROVIDER, STORAGE_INSTANCES_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StorageModule, [{\n    type: NgModule,\n    args: [{\n      providers: [DEFAULT_STORAGE_INSTANCE_PROVIDER, STORAGE_INSTANCES_PROVIDER]\n    }]\n  }], () => [], null);\n})();\nfunction provideStorage(fn, ...deps) {\n  return {\n    ngModule: StorageModule,\n    providers: [{\n      provide: PROVIDED_STORAGE_INSTANCES,\n      useFactory: storageInstanceFactory(fn),\n      multi: true,\n      deps: [NgZone, Injector, ɵAngularFireSchedulers, FirebaseApps,\n      // Defensively load Auth first, if provided\n      [new Optional(), AuthInstances], [new Optional(), ɵAppCheckInstances], ...deps]\n    }]\n  };\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst fromTask = ɵzoneWrap(fromTask$1, true);\nconst percentage = ɵzoneWrap(percentage$1, true);\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst connectStorageEmulator = ɵzoneWrap(connectStorageEmulator$1, true);\nconst deleteObject = ɵzoneWrap(deleteObject$1, true);\nconst getBlob = ɵzoneWrap(getBlob$1, true);\nconst getBytes = ɵzoneWrap(getBytes$1, true);\nconst getDownloadURL = ɵzoneWrap(getDownloadURL$1, true);\nconst getMetadata = ɵzoneWrap(getMetadata$1, true);\nconst getStorage = ɵzoneWrap(getStorage$1, true);\nconst getStream = ɵzoneWrap(getStream$1, true);\nconst list = ɵzoneWrap(list$1, true);\nconst listAll = ɵzoneWrap(listAll$1, true);\nconst ref = ɵzoneWrap(ref$1, true);\nconst updateMetadata = ɵzoneWrap(updateMetadata$1, true);\nconst uploadBytes = ɵzoneWrap(uploadBytes$1, true);\nconst uploadBytesResumable = ɵzoneWrap(uploadBytesResumable$1, true);\nconst uploadString = ɵzoneWrap(uploadString$1, true);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Storage, StorageInstances, StorageModule, connectStorageEmulator, deleteObject, fromTask, getBlob, getBytes, getDownloadURL, getMetadata, getStorage, getStream, list, listAll, percentage, provideStorage, ref, storageInstance$, updateMetadata, uploadBytes, uploadBytesResumable, uploadString };\n"],
  "mappings": "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",
  "names": ["fromTask", "percentage", "connectStorageEmulator", "deleteObject", "getBlob", "getBytes", "getDownloadURL", "getMetadata", "getStorage", "getStream", "list", "listAll", "ref", "updateMetadata", "uploadBytes", "uploadBytesResumable", "uploadString"]
}
